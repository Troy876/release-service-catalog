---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: update-fbc-catalog-task
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task to submit a IIB build request to add/update fbc-fragments to an index image
  params:
    - name: fbcFragments
      type: string
      description: FBC fragments built by Konflux as JSON array (e.g. ["fragment1", "fragment2"])
    - name: fromIndex
      type: string
      description: >-
        Index image (catalog of catalogs) the FBC fragment will be added to
    - name: buildTags
      type: string
      description: >-
        List of additional tags the internal index image copy should be
        tagged with
    - name: addArches
      type: string
      description: List of arches the index image should be built for
    - name: buildTimeoutSeconds
      type: string
      default: "3600"
      description: Timeout seconds to receive the build state
    - name: iibServiceAccountSecret
      type: string
      description: Secret with IIB credentials to be used
    - name: publishingCredentials
      type: string
      description: Secret containing the publishing credentials used to fetch the image config
    - name: mustPublishIndexImage
      type: string
      default: "false"
      description: Whether the index image should be published (pre-determined by prepare-fbc-parameters)
    - name: mustOverwriteFromIndexImage
      type: string
      default: "false"
      description: Whether to overwrite the from index image (pre-determined by prepare-fbc-parameters)
  results:
    - name: jsonBuildInfo
      description: JSON build information for the requested build
    - name: buildState
      description: IIB Service build state
    - name: indexImageDigests
      description: The digests for each arch for the manifest list of the index image
    - name: iibLog
      description: The link to the log from the IIB request
    - name: exitCode
      description: The exit code from the task
  steps:
    - name: update-fbc-catalog-prepare-and-call-iib-step
      image: >-
        quay.io/konflux-ci/release-service-utils:9c82b0f13e40e76150835b628c86ce05ae95a366
      computeResources:
        limits:
          memory: 512Mi
        requests:
          memory: 512Mi
          cpu: '1'
      env:
        - name: IIB_SERVICE_URL
          valueFrom:
            secretKeyRef:
              name: iib-services-config
              key: url
        - name: IIB_OVERWRITE_FROM_INDEX_USERNAME
          valueFrom:
            secretKeyRef:
              name: iib-overwrite-fromimage-credentials
              key: username
        - name: IIB_OVERWRITE_FROM_INDEX_TOKEN
          valueFrom:
            secretKeyRef:
              name: iib-overwrite-fromimage-credentials
              key: token
        - name: KRB5_CONF_CONTENT
          valueFrom:
            secretKeyRef:
              name: iib-services-config
              key: krb5.conf
        - name: FBC_FRAGMENTS
          value: $(params.fbcFragments)
        - name: PUBLISHING_CREDENTIAL
          valueFrom:
            secretKeyRef:
              key: targetIndexCredential
              name: $(params.publishingCredentials)
              optional: true
      script: |
        #!/usr/bin/env bash

        # checks if there is any previous build for the same set of fbc_fragments.
        # fragments are sorted for comparison to ensure consistent matching.
        # in case multiple builds are found, returns only the last one.
        # shellcheck disable=SC2329 # function is called later in this script
        check_previous_build() {
          user="${1}"
          from_index="${2}"
          fbc_fragments_json="${3}"
          current_build_tags="${4:-[]}"  # PLR identifier tags from add-fbc-contribution

          # Step 1: Look for completed builds using server-side state filtering which allows us 
          completed_build=$(curl -s "${IIB_SERVICE_URL}/builds?user=${user}&from_index=${from_index}&state=complete" | \
            jq --argjson fbc_fragments "${fbc_fragments_json}" \
              '[.items[] |
                select(.fbc_fragments != null) |
                select((.fbc_fragments | sort) == $fbc_fragments) |
                select(.distribution_scope == "prod" or .distribution_scope == null)
              ] | sort_by(.updated) | last // empty')

          if [ -n "${completed_build}" ] && [ "${completed_build}" != "null" ]; then
            # Validate completed build freshness (existing logic remains unchanged)
            indexImageResolved="$(jq -r '.index_image_resolved' <<< "${completed_build}")"
            newCatalogCreatedDate="$(date --date "$(skopeo inspect \
              --retry-times 3 --config "docker://${indexImageResolved}" | \
              jq -r .created)" "+%s")"

            create_auth_file
            fromIndexCreated="$(skopeo inspect --retry-times 3 --config "docker://${from_index}" | \
              jq -r .created)"

            if [ -z "${fromIndexCreated}" ]; then
              return 0
            fi

            upstreamCatalogCreatedDate="$(date --date "${fromIndexCreated}" "+%s")"
            if [ "${newCatalogCreatedDate}" -lt "${upstreamCatalogCreatedDate}" ]; then
              return 0
            fi

            # Completed build is valid for reuse
            echo "${completed_build}"
            return 0
          fi

          # Step 2: Look for in-progress builds with PLR collision prevention
          if [ "${current_build_tags}" != "[]" ] && [ -n "${current_build_tags}" ]; then
            in_progress_build=$(curl -s \
              "${IIB_SERVICE_URL}/builds?user=${user}&from_index=${from_index}&state=in_progress" | \
              jq --argjson fbc_fragments "${fbc_fragments_json}" \
                 --argjson current_tags "${current_build_tags}" \
                '[.items[] |
                  select(.fbc_fragments != null) |
                  select((.fbc_fragments | sort) == $fbc_fragments) |
                  select(.distribution_scope == "prod" or .distribution_scope == null) |
                  select(.build_tags != null and ($current_tags | length > 0) and
                         ($current_tags | map(. as $tag | . | IN(.build_tags[])) | any))
                ] | sort_by(.updated) | last // empty')

            if [ -n "${in_progress_build}" ] && [ "${in_progress_build}" != "null" ]; then
              echo "${in_progress_build}"
              return 0
            fi
          fi

          # No suitable build found
          return 0
        }

        create_auth_file() {
          mkdir -p "${HOME}/.config/containers"
          fromIndex="$(params.fromIndex)"
          authName="${fromIndex%:*}"

          # disabling debug to not leak the token
          set +x
          jq -n --arg authName "${authName}" \
                --arg token "$(base64 -w 0 < <(printf %s "${PUBLISHING_CREDENTIAL}"))" \
                '.auths[$authName].auth = $token' > "${HOME}/.config/containers/auth.json"
          set -x
        }

        # performs kerberos authentication.
        base64 -d /mnt/service-account-secret/keytab > "/tmp/keytab"

        KRB5_TEMP_CONF=$(mktemp)
        KRB5_PRINCIPAL=$(cat /mnt/service-account-secret/principal)

        echo "${KRB5_CONF_CONTENT}" > "${KRB5_TEMP_CONF}"
        export KRB5_CONFIG="${KRB5_TEMP_CONF}"
        export KRB5_TRACE=/dev/stderr

        retry 5 kinit -V "${KRB5_PRINCIPAL}" -k -t "/tmp/keytab"

        set -x

        FROM_INDEX="$(params.fromIndex)"

        # Validate that required environment variables are set
        if [ -z "${FBC_FRAGMENTS:-}" ]; then
            echo "Error: FBC_FRAGMENTS environment variable is required"
            exit 1
        fi
        if [ -z "${FROM_INDEX:-}" ]; then
            echo "Error: FROM_INDEX environment variable is required"
            exit 1
        fi
        
        # validate fbcFragments parameter is valid JSON array
        if ! echo "${FBC_FRAGMENTS}" | jq -e . >/dev/null 2>&1; then
          echo "Error: fbcFragments parameter must be a valid JSON array"
          jq -n '{ "state": "failed", "state_reason": "Invalid fbcFragments parameter" }' \
            | tee "$(results.buildState.path)"
          echo -n 1 > "$(results.exitCode.path)"
          exit 1
        fi
        
        # check if fbcFragments array is empty
        if [ "$(echo "${FBC_FRAGMENTS}" | jq 'length')" -eq 0 ]; then
          echo "Error: fbcFragments array is empty - no fragments to process"
          jq -n '{ "state": "failed", "state_reason": "Empty fbcFragments array" }' | tee "$(results.buildState.path)"
          echo -n 1 > "$(results.exitCode.path)"
          exit 1
        fi
        
        # Use pre-determined publishing decisions from prepare-fbc-parameters
        echo "Processing fragments: ${FBC_FRAGMENTS}"
        mustOverwriteFromIndexImage="$(params.mustOverwriteFromIndexImage)"
        mustPublishIndexImage="$(params.mustPublishIndexImage)"

        echo "Using pre-determined publishing decisions from prepare-fbc-parameters:"
        echo "             \`mustOverwriteFromIndexImage==${mustOverwriteFromIndexImage}\`"
        echo "             \`mustPublishIndexImage==${mustPublishIndexImage}\`"

        # Sort fragments once for consistent use throughout the script
        sorted_fbc_fragments=$(echo "${FBC_FRAGMENTS}" | jq 'sort')

        # if it finds a build which is completed or in progress, it should exit this step and jump to
        # the next step `s-wait-for-build-state` which will watch the build until it is completed.
        # Pass build_tags to enable PLR filtering for in-progress builds
        build_tags_param="$(params.buildTags)"
        build=$(check_previous_build "${KRB5_PRINCIPAL}" "${FROM_INDEX}" \
                  "${sorted_fbc_fragments}" "${build_tags_param}")
        if [ -n "${build}" ]; then
          echo "=== A previous build for this fragment was found ==="
          echo "${build}" | gzip -c | base64 -w0 | tee "$(results.jsonBuildInfo.path)"
          exit 0
        fi

        # adds the json request parameters to a file to be used as input data
        # for curl and preventing shell expansion.
        json_input="/tmp/$$.tmp"
        json_raw_input="/tmp/$$_raw.tmp"

        cat > "$json_raw_input" <<JSON
        {
          "fbc_fragments": ${sorted_fbc_fragments},
          "from_index": "${FROM_INDEX}",
          "build_tags": $(params.buildTags),
          "add_arches": $(params.addArches),
          "overwrite_from_index": ${mustOverwriteFromIndexImage},
          "overwrite_from_index_token": "${IIB_OVERWRITE_FROM_INDEX_USERNAME}:${IIB_OVERWRITE_FROM_INDEX_TOKEN}"
        }
        JSON

        # filtering out empty params
        jq -r '
          if .overwrite_from_index == false then del(( .overwrite_from_index, .overwrite_from_index_token)) else . end |
          if(.add_arches | length) == 0 then del(.add_arches) else . end |
          if(.build_tags | length) == 0 then del(.build_tags) else . end' "${json_raw_input}" > "${json_input}"

        jq -n '{ "state": "in_progress", "state_reason": "Calling IIB endpoint" }' | tee "$(results.buildState.path)"
        # adds image to the index.
        iib_response=$(curl -u : --negotiate -s -X POST \
          -H "Content-Type: application/json" -d@"${json_input}" --insecure \
          "${IIB_SERVICE_URL}/builds/fbc-operations")

        # checks if the previous call returned an error and exits if so
        if jq -e -r ".error | select( . != null )" <<< "${iib_response}" >/dev/null; then
            jq -n '{ "state": "failed", "state_reason": "IIB service error" }' | tee "$(results.buildState.path)"
            echo -n 1 > "$(results.exitCode.path)"
            exit 1
        fi
        
        # compress and store the response only after error check passes
        echo "${iib_response}" | gzip -c | base64 -w0 > "$(results.jsonBuildInfo.path)"
      volumeMounts:
        - name: service-account-secret
          mountPath: /mnt/service-account-secret
    - name: update-fbc-catalog-wait-for-iib-build-step
      image: >-
        quay.io/konflux-ci/release-service-utils:9c82b0f13e40e76150835b628c86ce05ae95a366
      computeResources:
        limits:
          memory: 256Mi
        requests:
          memory: 256Mi
          cpu: 250m
      env:
        - name: IIB_SERVICE_URL
          valueFrom:
            secretKeyRef:
              name: iib-services-config
              key: url
      script: |
        #!/usr/bin/env bash
        # shellcheck disable=SC2317 # shellcheck calls all the commands in the function unreachable
        set -x

        # shellcheck disable=SC2329 # function is used with timeout command
        watch_build_state() {
            build_id="$(base64 -d < "$(results.jsonBuildInfo.path)" | gunzip | jq -r ".id")"
            state=""
            while true; do
                #
                # fetching build information.
                build_info=$(curl -s "${IIB_SERVICE_URL}/builds/${build_id}")
                # get state from the build information.
                state="$(jq -r ".state" <<< "${build_info}")"
                # remove the history as it breaks the results build up
                jq -r 'del(.state_history)' <<< "${build_info}" | jq -c . | \
                  gzip -c | base64 -w0 > "$(results.jsonBuildInfo.path)"
                url="$(jq -r ".logs.url" <<< "${build_info}")"
                echo IIB log url is: "${url}" > "$(results.iibLog.path)"
                case ${state} in
                  "complete")
                    # Determine final index image based on release strategy
                    if [ "$(params.mustOverwriteFromIndexImage)" = "true" ] && \
                       [ "$(params.mustPublishIndexImage)" = "true" ]; then
                        # Production build: use IIB-generated index_image
                        final_index_image=$(jq -r ".index_image" <<< "${build_info}")
                        # If we overwrote the from index, verify the index_image matches the fromIndex from build data
                        expected_from_index=$(jq -r ".from_index" <<< "${build_info}")
                        if [ "${final_index_image}" != "${expected_from_index}" ]; then
                            echo "Error: Build completed but index_image '${final_index_image}' does not match" \
                              "expected fromIndex '${expected_from_index}'"
                            echo "This indicates that the from index was not properly overwritten"
                            error_msg="Index image mismatch: expected ${expected_from_index}, got ${final_index_image}."
                            jq -n --arg reason "${error_msg}" \
                              '{ "state": "failed", "state_reason": $reason }' > "$(results.buildState.path)"
                            return 1
                        fi
                    elif [ "$(params.mustOverwriteFromIndexImage)" = "false" ] && \
                         [ "$(params.mustPublishIndexImage)" = "true" ]; then
                        # Hotfix/preGA build: use IIB-generated index_image
                        final_index_image=$(jq -r ".index_image" <<< "${build_info}")
                    elif [ "$(params.mustOverwriteFromIndexImage)" = "false" ] && \
                         [ "$(params.mustPublishIndexImage)" = "false" ]; then
                        # Staging build: use IIB-generated index_image
                        final_index_image=$(jq -r ".index_image" <<< "${build_info}")
                    else
                        echo "Error: Invalid combination of mustOverwriteFromIndexImage=true" \
                             "and mustPublishIndexImage=false"
                        echo "This could be caused by multiple pipelines releasing to production running in parallel"
                        error_msg="Invalid release strategy combination."
                        jq -n --arg reason "${error_msg}" \
                          '{ "state": "failed", "state_reason": $reason }' > "$(results.buildState.path)"
                        return 1
                    fi
                    break ;;
                  "failed") break ;;
                  *) echo -en "."; sleep 30; continue ;;
                esac
            done
            echo
            base64 -d < "$(results.jsonBuildInfo.path)" | gunzip | \
              jq -cr '{ "state": .state, "state_reason": .state_reason }' \
            | tee "$(results.buildState.path)"
            test "${state}" = "complete" && exit 0 || exit 1
        }

        echo -en "waiting for build state to exit..."
        # adding timeout here due to the Task timeout not accepting $(params.buildTimeoutSeconds)
        # as parameter.
        export -f watch_build_state
        timeout "$(params.buildTimeoutSeconds)" bash -c watch_build_state
        BUILDEXIT=$?

        # it should continue only if the IIB build status is complete
        if [ ${BUILDEXIT} -eq 0 ]; then
            echo -n 0 > "$(results.exitCode.path)"

            # get the manifest digests
            indexImageCopy=$(base64 -d < "$(results.jsonBuildInfo.path)" | gunzip | \
              jq -cr .internal_index_image_copy)
            # Use this to obtain the manifest digests for each arch in manifest list
            indexImageDigestsRaw=$(skopeo inspect --retry-times 3 --raw "docker://${indexImageCopy}")
            # according the IIB team,
            #  "all index images will always be multi-arch with a manifest list"
            #
            indexImageDigests=$(echo "${indexImageDigestsRaw}" | \
               jq -r \
               '.manifests[]? | select(.mediaType=="application/vnd.docker.distribution.manifest.v2+json") | .digest' \
               | tr '\n' ' ' | sed 's/ $//')  # make sure the result is on one line and remove trailing space
            echo -n "${indexImageDigests}" > "$(results.indexImageDigests.path)"
            if [ -z "${indexImageDigests}" ] ; then
              echo "Index image produced is not multi-arch with a manifest list"
              echo -n 1 > "$(results.exitCode.path)"
            fi
        else
            if [ ${BUILDEXIT} -eq 124 ]; then
                echo "Timeout while waiting for the build to finish"
                jq -n '{ "state": "failed", "state_reason": "Build timeout" }' | tee "$(results.buildState.path)"
            else
                echo "Build failed with exit code ${BUILDEXIT}"
                jq -n --arg exit_code "$BUILDEXIT" \
                  '{ "state": "failed", "state_reason": ("Build failed with exit code " + $exit_code) }' \
                  | tee "$(results.buildState.path)"
            fi
            echo -n "" > "$(results.indexImageDigests.path)"
            echo -n "$BUILDEXIT" > "$(results.exitCode.path)"
        fi
        # We don't put the log in a result because tekton results are too limited for what we can put
        # to be useful, but still print it for debugging
        curl -s "$(awk '{print $NF}' < "$(results.iibLog.path)")"

        exit "${BUILDEXIT}"
  volumes:
    - name: service-account-secret
      secret:
        secretName: $(params.iibServiceAccountSecret)
        defaultMode:
          0400
